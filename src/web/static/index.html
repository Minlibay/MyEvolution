<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{{SEO_TITLE}}</title>
  <meta name="description" content="{{SEO_DESCRIPTION}}" />
  <meta name="keywords" content="{{SEO_KEYWORDS}}" />
  <meta property="og:title" content="{{SEO_TITLE}}" />
  <meta property="og:description" content="{{SEO_DESCRIPTION}}" />
  <meta property="og:type" content="website" />
  <meta property="og:image" content="{{SEO_OG_IMAGE}}" />
  <link rel="icon" href="{{FAVICON_URL}}" type="image/svg+xml" />
  <style>
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 0; background: #0b1020; color: #e7e9ee; }
    header { padding: 12px 16px; border-bottom: 1px solid rgba(255,255,255,0.1); display:flex; align-items:center; gap:12px; }
    button { background:#243bff; color:#fff; border:0; padding:8px 10px; border-radius:8px; cursor:pointer; }
    button.secondary { background:#2a2f45; }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    .layout { display:grid; grid-template-columns: 1fr 420px; gap: 12px; padding: 12px; min-height: calc(100vh - 64px); }
    .panel { background: rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08); border-radius: 12px; overflow:hidden; }
    .panel h3 { margin:0; padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,0.08); font-size: 14px; color:#cbd2ff; }
    #canvasWrap { padding: 10px; position: relative; overflow: visible; }
    canvas { background: #070a14; border-radius: 10px; width: 100%; height: 720px; }
    #events { height: 720px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .event { padding: 8px 10px; border-bottom: 1px solid rgba(255,255,255,0.06); }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    input[type=range] { width: 180px; }
    .kv { display:flex; gap:10px; font-size: 12px; color:#aab0c0; }
    .kv b { color:#e7e9ee; }

    #agentTooltip {
      position: absolute;
      left: 0;
      top: 0;
      display: none;
      pointer-events: none;
      z-index: 40;
      background: rgba(17, 22, 42, 0.95);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 10px;
      padding: 8px 10px;
      min-width: 140px;
      max-width: 260px;
      font-size: 12px;
      color: #e7e9ee;
      box-shadow: 0 8px 24px rgba(0,0,0,0.35);
    }
    #agentTooltip .title { font-weight: 700; margin-bottom: 6px; color: #cbd2ff; }
    #agentTooltip .muted { color: #aab0c0; }
    #agentTooltip .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    #camPad {
      position: absolute;
      right: 16px;
      top: 16px;
      z-index: 12;
      display: grid;
      grid-template-columns: 38px 38px 38px;
      grid-template-rows: 38px 38px 38px 38px;
      gap: 6px;
      pointer-events: auto;
    }
    .camBtn {
      width: 38px;
      height: 38px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(17, 22, 42, 0.80);
      color: #e7e9ee;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor: pointer;
      user-select: none;
      font-size: 16px;
    }
    .camBtn:active { transform: translateY(1px); }
    .camBtn:disabled { opacity: 0.45; cursor: not-allowed; }

    #bannerSlot {
      width: 728px;
      height: 90px;
      border-radius: 12px;
      border: 1px dashed rgba(255,255,255,0.22);
      background: rgba(255,255,255,0.03);
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      color: rgba(231,233,238,0.65);
      font-size: 12px;
    }
    @media (max-width: 1180px) {
      #bannerSlot { display: none; }
    }

    #cookieBar {
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: 12px;
      z-index: 60;
      background: rgba(17, 22, 42, 0.98);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 14px;
      box-shadow: 0 16px 60px rgba(0,0,0,0.55);
      padding: 12px 14px;
      display: none;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
    }
    #cookieText {
      font-size: 12px;
      color: #c9cedc;
      line-height: 1.35;
      max-width: 980px;
    }
    #cookieText b { color: #e7e9ee; }
    #cookieText a { color: #cbd2ff; text-decoration: underline; }
    #worldPanel {
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 64px - 24px);
      overflow: visible;
    }
    #chatSection {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 260px;
    }
    #chatBox {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-height: 180px;
    }
    #chatMessages {
      flex: 1;
      min-height: 160px;
      overflow: auto;
    }
    #chatAnnounce {
      display:none;
      margin-bottom: 8px;
      padding: 10px 10px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(17, 22, 42, 0.70);
      color: #dbe0f3;
      font-size: 12px;
      line-height: 1.35;
    }
    #chatAnnounce b { color: #cbd2ff; }
  </style>
</head>
<body>
<header>
  <div class="row">
    <div class="kv" id="status"></div>
  </div>

  <div style="flex:1"></div>
  <div id="bannerSlot">
    <div id="bannerContainer">{{BANNER_HTML}}</div>
  </div>
</header>

<div class="layout">
  <div class="panel" id="worldPanel">
    <h3>Мир (агенты/объекты)</h3>
    <div id="worldControls" class="row" style="padding:10px 12px; border-bottom: 1px solid rgba(255,255,255,0.08); display:none;">
      <button id="btnCreateAgent" class="secondary">Создать агента</button>
      <div id="createAgentState" style="font-size:12px; color:#aab0c0;"></div>
    </div>
    <div id="canvasWrap">
      <canvas id="cv" width="1000" height="720"></canvas>
      <div id="agentTooltip"></div>
      <div id="camPad">
        <button id="camZoomIn" class="camBtn" title="приблизить" type="button">+</button>
        <div></div>
        <button id="camZoomOut" class="camBtn" title="отдалить" type="button">−</button>

        <div></div>
        <button id="camUp" class="camBtn" title="вверх" type="button">↑</button>
        <div></div>

        <button id="camLeft" class="camBtn" title="влево" type="button">←</button>
        <button id="camDown" class="camBtn" title="вниз" type="button">↓</button>
        <button id="camRight" class="camBtn" title="вправо" type="button">→</button>

        <button id="camReset" class="camBtn" title="сброс (R)" type="button">R</button>
        <div></div>
        <div></div>
      </div>
    </div>
    <h3>Чат</h3>
    <div id="chatSection" style="padding:10px 12px; border-top: 1px solid rgba(255,255,255,0.08);">
      <div id="chatAuth" class="row" style="gap:10px; align-items:flex-end;">
        <div style="display:flex; flex-direction:column; gap:6px;">
          <div style="font-size:12px; color:#aab0c0;">Логин</div>
          <input id="authUser" type="text" placeholder="username" style="width:140px; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;" />
        </div>
        <div style="display:flex; flex-direction:column; gap:6px;">
          <div style="font-size:12px; color:#aab0c0;">Пароль</div>
          <input id="authPass" type="password" placeholder="password" style="width:140px; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;" />
        </div>
        <button id="btnLogin">Войти</button>
        <button id="btnRegister" class="secondary">Регистрация</button>
        <button id="btnLogout" class="secondary" style="display:none;">Выйти</button>
        <div id="authState" style="font-size:12px; color:#aab0c0;"></div>
      </div>

      <div id="accountBar" class="row" style="display:none; gap:10px; align-items:center; margin-top:10px;">
        <div id="accountText" style="font-size:12px; color:#aab0c0;"></div>
        <a id="adminLink" href="/adminkins" style="display:none; font-size:12px; color:#cbd2ff;">админка</a>
        <button id="btnLogout2" class="secondary">Выйти</button>
      </div>

      <div id="chatBox" style="margin-top:10px; display:none;">
        <div id="chatAnnounce"><b>Анонс:</b> <span id="chatAnnounceText"></span></div>
        <div id="chatMessages" style="border:1px solid rgba(255,255,255,0.12); border-radius:10px; padding:8px; background:rgba(0,0,0,0.18);"></div>
        <div class="row" style="margin-top:8px;">
          <input id="chatInput" type="text" placeholder="сообщение..." style="flex:1; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;" />
          <button id="btnSend" disabled>Отправить</button>
        </div>
      </div>
    </div>
  </div>
  <div class="panel">
    <h3>История</h3>
    <div id="history" style="max-height:220px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px;"></div>
    <h3>События (хвост)</h3>
    <div id="events"></div>
    <h3>Новости</h3>
    <div style="padding:10px 12px; border-top: 1px solid rgba(255,255,255,0.08);">
      <div id="newsAdmin" style="display:none; margin-bottom:10px;">
        <div style="font-size:12px; color:#aab0c0; margin-bottom:6px;">Админка: добавить новость</div>
        <input id="newsTitle" type="text" placeholder="заголовок" style="width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;" />
        <textarea id="newsText" placeholder="текст" style="width:100%; margin-top:6px; height:80px; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;"></textarea>
        <div class="row" style="margin-top:6px;">
          <button id="btnPostNews">Опубликовать</button>
          <div id="newsAdminState" style="font-size:12px; color:#aab0c0;"></div>
        </div>
      </div>
      <div id="newsList"></div>
    </div>
    <div class="panel">
      <h3>Твой агент</h3>
      <div id="myAgent" style="padding:10px 12px; min-height:160px;">
        <div id="myAgentState" class="muted">Войдите и создайте агента, чтобы следить за ним.</div>
        <div id="myAgentBody" style="display:none;">
          <div style="font-weight:700; margin-bottom:6px;" id="myAgentName"></div>
          <div class="muted" id="myAgentOwner" style="margin-bottom:6px;"></div>
          <div style="font-size:12px; color:#aab0c0;">Статус</div>
          <div id="myAgentStatus" style="margin-bottom:8px; font-size:13px;"></div>
          <div class="muted" style="font-size:12px;">Нужды</div>
          <div id="myAgentNeeds" style="font-size:13px; margin-bottom:8px;"></div>
          <div class="muted" style="font-size:12px;">Возраст / здоровье / энергия</div>
          <div id="myAgentVitals" style="font-size:13px;"></div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="agentModal" style="display:none; position:fixed; inset:0; background: rgba(0,0,0,0.55); z-index: 50; align-items:center; justify-content:center;">
  <div style="width:min(520px, calc(100vw - 24px)); background: rgba(17, 22, 42, 0.98); border:1px solid rgba(255,255,255,0.18); border-radius: 14px; box-shadow: 0 16px 60px rgba(0,0,0,0.55); overflow:hidden;">
    <div class="row" style="justify-content:space-between; padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.10);">
      <div>
        <b>Создать агента</b>
        <div style="font-size:12px; color:#aab0c0; margin-top:4px;">Агент появится в мире и будет участвовать в эксперименте</div>
      </div>
      <button id="btnCloseAgentModal" class="secondary">Закрыть</button>
    </div>
    <div style="padding: 14px;">
      <div style="font-size:12px; color:#aab0c0; margin-bottom:6px;">Имя</div>
      <input id="agentName" type="text" placeholder="например: Кин" style="width:100%; padding:10px; border-radius:10px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;" />

      <div style="font-size:12px; color:#aab0c0; margin-top:12px; margin-bottom:6px;">Пол</div>
      <div class="row">
        <label class="row" style="gap:8px; font-size:12px; color:#aab0c0;"><input type="radio" name="agentSex" value="male" checked /> мужской</label>
        <label class="row" style="gap:8px; font-size:12px; color:#aab0c0;"><input type="radio" name="agentSex" value="female" /> женский</label>
      </div>

      <div style="font-size:12px; color:#aab0c0; margin-top:12px; margin-bottom:6px;">Характеристики (5 очков)</div>
      <div class="row" style="gap:10px; flex-wrap:wrap; align-items:flex-end;">
        <div style="display:flex; flex-direction:column; gap:6px; min-width:120px;">
          <div style="font-size:12px; color:#aab0c0;">Сила</div>
          <input id="agentStatsStrength" type="number" min="0" max="3" value="0" style="width:120px; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;" />
        </div>
        <div style="display:flex; flex-direction:column; gap:6px; min-width:120px;">
          <div style="font-size:12px; color:#aab0c0;">Интеллект</div>
          <input id="agentStatsIntelligence" type="number" min="0" max="3" value="0" style="width:120px; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;" />
        </div>
        <div style="display:flex; flex-direction:column; gap:6px; min-width:120px;">
          <div style="font-size:12px; color:#aab0c0;">Социальность</div>
          <input id="agentStatsSocial" type="number" min="0" max="3" value="0" style="width:120px; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;" />
        </div>
        <div style="display:flex; flex-direction:column; gap:6px; min-width:120px;">
          <div style="font-size:12px; color:#aab0c0;">Выносливость</div>
          <input id="agentStatsEndurance" type="number" min="0" max="3" value="0" style="width:120px; padding:8px; border-radius:10px; border:1px solid rgba(255,255,255,0.12); background:#0b1020; color:#e7e9ee;" />
        </div>
      </div>

      <div class="row" style="margin-top:10px; gap:8px; flex-wrap:wrap; align-items:center; justify-content:space-between;">
        <div id="agentStatsLeft" style="font-size:12px; color:#aab0c0;"></div>
        <div class="row" style="gap:8px; flex-wrap:wrap;">
          <button id="btnPresetInventor" class="secondary">Изобретатель</button>
          <button id="btnPresetSurvivor" class="secondary">Выживальщик</button>
          <button id="btnPresetLeader" class="secondary">Вождь</button>
        </div>
      </div>

      <div class="row" style="margin-top:14px; justify-content:space-between;">
        <div id="agentModalState" style="font-size:12px; color:#aab0c0;"></div>
        <div class="row">
          <button id="btnSubmitAgent">Создать</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="welcomeModal" style="display:none; position:fixed; inset:0; background: rgba(0,0,0,0.55); z-index: 55; align-items:center; justify-content:center;">
  <div style="width:min(640px, calc(100vw - 24px)); background: rgba(17, 22, 42, 0.98); border:1px solid rgba(255,255,255,0.18); border-radius: 14px; box-shadow: 0 16px 60px rgba(0,0,0,0.55); overflow:hidden;">
    <div class="row" style="justify-content:space-between; padding: 12px 14px; border-bottom: 1px solid rgba(255,255,255,0.10);">
      <div>
        <b>О проекте</b>
        <div style="font-size:12px; color:#aab0c0; margin-top:4px;">Коротко: это интерактивная симуляция эволюции поведения агентов и появления инструментов</div>
      </div>
      <button id="btnCloseWelcome" class="secondary">Закрыть</button>
    </div>
    <div style="padding: 14px; font-size: 13px; color: #d4d8e6; line-height: 1.4;">
      <div style="margin-bottom:10px;">
        Здесь можно наблюдать за жизнью агентов в 2D-мире: они перемещаются, собирают ресурсы, общаются, пытаются выжить, а также могут открывать и использовать инструменты.
      </div>
      <div style="margin-bottom:10px;">
        Если ты зарегистрируешься и войдёшь, ты сможешь <b>создать собственного агента</b> — он появится в мире, и ты сможешь следить за его состоянием, действиями и судьбой.
      </div>
      <div class="row" style="justify-content:flex-end; gap:10px;">
        <button id="btnWelcomeOk">Понятно</button>
      </div>
    </div>
  </div>
</div>

<div id="cookieBar" class="row">
  <div id="cookieText">
    <b>Файлы cookie</b>. Мы используем cookie и похожие технологии для обеспечения работы сайта, безопасности, авторизации/сессии, сохранения настроек интерфейса и аналитики.
    Cookie могут содержать технические идентификаторы и информацию о действиях на сайте. Нажимая «Принять» и продолжая пользоваться сайтом, ты даёшь согласие на обработку таких данных и установку cookie.
    Согласие можно отозвать, удалив cookie в браузере и/или запретив их в настройках браузера (при этом часть функций может работать некорректно).
    Если используются сторонние сервисы (например, сети баннеров/аналитики), они могут устанавливать свои cookie согласно своим политикам. Подробнее: <a href="/privacy" target="_blank" rel="noopener noreferrer">Политика cookie/конфиденциальности</a>.
  </div>
  <div class="row" style="gap:8px; flex-wrap:nowrap;">
    <button id="btnCookieAccept">Принять</button>
  </div>
</div>

<script>
  const status = document.getElementById('status');

  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');

  const agentTooltip = document.getElementById('agentTooltip');

  const welcomeModal = document.getElementById('welcomeModal');
  const btnCloseWelcome = document.getElementById('btnCloseWelcome');
  const btnWelcomeOk = document.getElementById('btnWelcomeOk');

  const cookieBar = document.getElementById('cookieBar');
  const btnCookieAccept = document.getElementById('btnCookieAccept');

  const sprites = {
    male: new Image(),
    female: new Image(),
  };

  sprites.male.src = '/static/sprites/male.png';
  sprites.female.src = '/static/sprites/female.png';

  const agentRenderState = new Map();

  let worldMapCache = {
    w: null,
    h: null,
    water: [],
    off: null,
  };

  let worldMapLoading = false;

  async function loadWorldMap() {
    if (worldMapLoading) return;
    worldMapLoading = true;
    try {
      const res = await fetch('/api/map', { cache: 'no-store' });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) return;
      const m = data.map || null;
      if (!m) return;
      const w = parseInt(m.width || 0, 10);
      const h = parseInt(m.height || 0, 10);
      const water = (m.terrain && Array.isArray(m.terrain.water)) ? m.terrain.water : [];
      worldMapCache = { w, h, water, off: null };
    } catch (e) {}
    finally { worldMapLoading = false; }
  }

  function buildWaterOffscreen(w, h, water) {
    try {
      const off = document.createElement('canvas');
      off.width = Math.max(1, w);
      off.height = Math.max(1, h);
      const octx = off.getContext('2d');
      octx.clearRect(0, 0, off.width, off.height);
      octx.fillStyle = 'rgba(46, 107, 255, 0.35)';
      for (const c of (water || [])) {
        try {
          const x = c[0] | 0;
          const y = c[1] | 0;
          if (x >= 0 && y >= 0 && x < w && y < h) octx.fillRect(x, y, 1, 1);
        } catch (e) {}
      }
      return off;
    } catch (e) {
      return null;
    }
  }

  // Camera (pan/zoom)
  const camera = { x: 0, y: 0, zoom: 1, _initialized: true };
  const cameraLimits = { minZoom: 0.75, maxZoom: 6 };
  let dragging = false;
  let dragStart = null;
  let autoCenteredOnce = false;

  function computeCameraLimits(snapshot) {
    if (!snapshot) return;
    // Let's enforce strict zoom limits.
    cameraLimits.minZoom = 0.5;
    cameraLimits.maxZoom = 15;
  }

  function clampCamera(snapshot) {
    if (!snapshot) return;
    computeCameraLimits(snapshot);

    camera.zoom = Math.max(cameraLimits.minZoom, Math.min(cameraLimits.maxZoom, camera.zoom));

    const worldW = cv.width * camera.zoom;
    const worldH = cv.height * camera.zoom;

    // Allow panning, but don't let the map completely leave the screen.
    // Let's keep at least 100px of the map visible.
    const padding = 100;
    const minX = cv.width - worldW - padding;
    const maxX = padding;
    const minY = cv.height - worldH - padding;
    const maxY = padding;

    if (worldW < cv.width) {
      camera.x = (cv.width - worldW) / 2;
    } else {
      camera.x = Math.max(minX, Math.min(maxX, camera.x));
    }

    if (worldH < cv.height) {
      camera.y = (cv.height - worldH) / 2;
    } else {
      camera.y = Math.max(minY, Math.min(maxY, camera.y));
    }
  }

  function centerOnAgents(snapshot) {
    if (!snapshot || !snapshot.agents || snapshot.agents.length === 0) return;
    const w = snapshot.world.width;
    const h = snapshot.world.height;
    const sx = cv.width / w;
    const sy = cv.height / h;

    let ax = 0;
    let ay = 0;
    for (const a of snapshot.agents) {
      ax += a.x;
      ay += a.y;
    }
    ax /= snapshot.agents.length;
    ay /= snapshot.agents.length;

    const px = ax * sx;
    const py = ay * sy;
    camera.x = cv.width / 2 - px * camera.zoom;
    camera.y = cv.height / 2 - py * camera.zoom;
    clampCamera(snapshot);
  }

  function resetCamera(snapshot) {
    camera.zoom = 1;
    camera.x = 0;
    camera.y = 0;
    clampCamera(snapshot);
  }

  function zoomAtCanvasPoint(canvasX, canvasY, factor) {
    if (!lastSnapshot) return;
    computeCameraLimits(lastSnapshot);
    const oldZoom = camera.zoom;
    let newZoom = oldZoom * factor;
    newZoom = Math.max(cameraLimits.minZoom, Math.min(cameraLimits.maxZoom, newZoom));
    if (Math.abs(newZoom - oldZoom) < 1e-6) return;
    camera.x = canvasX - (canvasX - camera.x) * (newZoom / oldZoom);
    camera.y = canvasY - (canvasY - camera.y) * (newZoom / oldZoom);
    camera.zoom = newZoom;
    clampCamera(lastSnapshot);
  }

  function nudgeCamera(dx, dy) {
    if (!lastSnapshot) return;
    camera.x += dx;
    camera.y += dy;
    clampCamera(lastSnapshot);
  }

  function bindHold(btn, onStep) {
    if (!btn) return;
    let t = null;
    let raf = null;
    const step = () => {
      try { onStep(); } catch (e) {}
      raf = requestAnimationFrame(step);
    };
    const stop = () => {
      if (raf) cancelAnimationFrame(raf);
      raf = null;
      if (t) clearTimeout(t);
      t = null;
    };
    btn.addEventListener('mousedown', (e) => {
      e.preventDefault();
      onStep();
      t = setTimeout(() => { raf = requestAnimationFrame(step); }, 180);
    });
    window.addEventListener('mouseup', stop);
    btn.addEventListener('mouseleave', stop);
  }

  const centerX = () => cv.width / 2;
  const centerY = () => cv.height / 2;

  if (camZoomIn) {
    camZoomIn.disabled = true;
    camZoomIn.title = 'зум отключен';
  }
  if (camZoomOut) {
    camZoomOut.disabled = true;
    camZoomOut.title = 'зум отключен';
  }
  if (camUp) { camUp.disabled = true; camUp.style.display = 'none'; }
  if (camDown) { camDown.disabled = true; camDown.style.display = 'none'; }
  if (camLeft) { camLeft.disabled = true; camLeft.style.display = 'none'; }
  if (camRight) { camRight.disabled = true; camRight.style.display = 'none'; }
  if (camReset) camReset.addEventListener('click', () => resetCamera(lastSnapshot));

  const basePan = () => 42;
  const panStep = () => basePan() * Math.max(1.0, camera.zoom * 0.55);
  if (camUp && !camUp.disabled) bindHold(camUp, () => nudgeCamera(0, panStep()));
  if (camDown && !camDown.disabled) bindHold(camDown, () => nudgeCamera(0, -panStep()));
  if (camLeft && !camLeft.disabled) bindHold(camLeft, () => nudgeCamera(panStep(), 0));
  if (camRight && !camRight.disabled) bindHold(camRight, () => nudgeCamera(-panStep(), 0));

  cv.addEventListener('wheel', (e) => {
    e.preventDefault();
    // zoom отключен
  }, { passive: false });

  function showWelcomeOnce() {
    try {
      const k = 'evosim_welcome_shown';
      if (localStorage.getItem(k) === '1') return;
      localStorage.setItem(k, '1');
      if (!welcomeModal) return;
      welcomeModal.style.display = 'flex';
    } catch (e) {}
  }

  function hideWelcome() {
    try { if (welcomeModal) welcomeModal.style.display = 'none'; } catch (e) {}
  }

  if (btnCloseWelcome) btnCloseWelcome.addEventListener('click', hideWelcome);
  if (btnWelcomeOk) btnWelcomeOk.addEventListener('click', hideWelcome);

  function showCookieOnce() {
    try {
      const k = 'evosim_cookie_ok';
      if (localStorage.getItem(k) === '1') return;
      if (cookieBar) cookieBar.style.display = 'flex';
    } catch (e) {}
  }

  function acceptCookies() {
    try {
      localStorage.setItem('evosim_cookie_ok', '1');
      if (cookieBar) cookieBar.style.display = 'none';
    } catch (e) {}
  }

  if (btnCookieAccept) btnCookieAccept.addEventListener('click', acceptCookies);

  try {
    showWelcomeOnce();
    showCookieOnce();
  } catch (e) {}

  cv.addEventListener('contextmenu', (e) => e.preventDefault());

  cv.addEventListener('mousedown', (e) => {
    // Like in admin editor: pan with RMB/MMB, keep LMB for selection/hover.
    if (e.button !== 1 && e.button !== 2) return;
    dragging = true;
    dragStart = { x: e.clientX, y: e.clientY, cx: camera.x, cy: camera.y };
  });
  window.addEventListener('mouseup', () => { dragging = false; dragStart = null; });
  window.addEventListener('mousemove', (e) => {
    if (!dragging || !dragStart) return;
    const dx = e.clientX - dragStart.x;
    const dy = e.clientY - dragStart.y;
    camera.x = dragStart.cx + dx;
    camera.y = dragStart.cy + dy;
    clampCamera(lastSnapshot);
  });

  cv.addEventListener('dblclick', (e) => {
    e.preventDefault();
    centerOnAgents(lastSnapshot);
  });

  window.addEventListener('keydown', (e) => {
    if (e.key === 'r' || e.key === 'R') {
      resetCamera(lastSnapshot);
    }
  });

  const ruAction = {
    move: 'идёт',
    gather: 'собирает',
    consume: 'ест',
    drink: 'пьёт',
    sleep: 'спит',
    communicate: 'общается',
    mate: 'спаривается',
    care: 'заботится о ребёнке',
    combine: 'крафтит',
    break: 'ломает',
    attack: 'охотится',
    rest: 'отдыхает',
  };

  function actionToRu(action) {
    if (!action) return '...';
    return ruAction[action] || 'действует';
  }

  function renderHistory(snapshot) {
    const el = document.getElementById('history');
    if (!el) return;
    const items = snapshot.history || [];
    el.innerHTML = '';

    const reasonRu = {
      'смерть Адама и Евы': 'все агенты погибли',
      'перезапуск': 'перезапуск',
      'ошибка симуляции': 'ошибка симуляции',
      'применение карты': 'применение карты',
      'перезапуск сервера': 'перезапуск сервера',
    };

    if (!items.length) {
      const div = document.createElement('div');
      div.className = 'event';
      div.textContent = 'История перезапусков пустая.';
      el.appendChild(div);
      return;
    }

    for (let i = items.length - 1; i >= 0; i--) {
      const h = items[i];
      const div = document.createElement('div');
      div.className = 'event';
      let extra = '';
      if (h.reason_details) {
        const d = h.reason_details;
        const agent = d.agent_id ? ` (${d.agent_id})` : '';
        const hng = (d.hunger === undefined || d.hunger === null) ? '—' : d.hunger.toFixed(2);
        const thr = (d.thirst === undefined || d.thirst === null) ? '—' : d.thirst.toFixed(2);
        const slp = (d.sleepiness === undefined || d.sleepiness === null) ? '—' : d.sleepiness.toFixed(2);
        const eng = (d.energy === undefined || d.energy === null) ? '—' : d.energy.toFixed(2);
        const hlth = (d.health === undefined || d.health === null) ? '—' : d.health.toFixed(2);
        const age = (d.age === undefined || d.age === null) ? '—' : d.age;
        if (d.cause_ru) {
          extra = `; ${d.cause_ru}${agent}; голод=${hng} жажда=${thr} сон=${slp} энергия=${eng} здоровье=${hlth} возраст=${age}`;
        } else if (d.message) {
          const where = d.where ? ` (${d.where})` : '';
          extra = `; ${d.message}${where}`;
          if (d.traceback) {
            try {
              const lines = String(d.traceback).split('\n').map(s => s.trim()).filter(Boolean);
              const tail = lines.slice(Math.max(0, lines.length - 6));
              const hint = tail.join(' | ');
              extra += `; tb: ${hint}`;
            } catch (e) {}
          }
        } else if (d.note) {
          extra = `; ${d.note}`;
        }
      }
      const rru = reasonRu[h.reason] || h.reason || 'завершён';
      const dur = h.duration_sec_wall ? ` · длительность ${h.duration_sec_wall.toFixed(1)}s` : '';
      div.textContent = `run #${h.run}: ${rru}; t=${h.ended_at_timestep} день=${h.ended_at_day} время=${h.ended_at_time}${dur}${extra}`;
      el.appendChild(div);
    }
  }

  function getSpriteSheet(sex) {
    if (sex === 'female') return sprites.female;
    return sprites.male;
  }

  function getFrameRect(img, col, row) {
    const fw = Math.floor(img.width / 4);
    const fh = Math.floor(img.height / 2);
    return { sx: col * fw, sy: row * fh, sw: fw, sh: fh };
  }

  function chooseFrame(agent, timestep) {
    // Sheet layout assumption:
    // row 0: walk cycle (2 frames) + (unused/back)
    // row 1: sit, gather/crouch, eat frame A, eat frame B
    const action = agent.last_action || 'rest';
    const phase = timestep % 2;

    if (action === 'move') {
      return { col: phase, row: 0, flip: agent.facing === 'right' };
    }
    if (action === 'gather' || action === 'combine') {
      return { col: 1, row: 1, flip: agent.facing === 'right' };
    }
    if (action === 'consume') {
      return { col: 2 + phase, row: 1, flip: agent.facing === 'right' };
    }
    // rest + default
    return { col: 0, row: 1, flip: agent.facing === 'right' };
  }

  function ping() {
    try { ws.send('ping'); } catch (e) {}
  }

  function colorForObject(type) {
    const map = { stone:'#8b8f9f', wood:'#9b6b3d', plant:'#2bd46a', berry:'#ff3b3b', bone:'#e7e7e7', fiber:'#ffd35c', animal:'#ff9a3b' };
    return map[type] || '#4aa3ff';
  }

  function colorForAgent(a) {
    if (a.health > 0.7) return '#41d67e';
    if (a.health > 0.4) return '#ffcf5c';
    return '#ff4d6d';
  }

  const ruObj = {
    stone: 'камень',
    wood: 'дерево',
    plant: 'растение',
    berry: 'ягоды',
    bone: 'кость',
    fiber: 'волокно',
    animal: 'мясо',
    water: 'вода',
  };

  const ruToolKind = {
    wooden_axe: 'деревянный топор',
    wooden_spear: 'деревянное копьё',
    stone_hammer: 'каменный молот',
  };

  function escapeHtml(s) {
    return String(s)
      .replaceAll('&', '&amp;')
      .replaceAll('<', '&lt;')
      .replaceAll('>', '&gt;')
      .replaceAll('"', '&quot;')
      .replaceAll("'", '&#39;');
  }

  function getHoverSnapshot() {
    const base = lastSnapshot || {};
    const agents = Array.isArray(lastAgents) ? lastAgents : (base.agents || []);
    const objects = Array.from(objectsState.values());
    const world = base.world || { width: 100, height: 100 };
    return { ...base, world, agents, objects };
  }

  function findAgentUnderCursor(snapshot, mx, my) {
    if (!snapshot || !snapshot.agents || snapshot.agents.length === 0) return null;

    const w = snapshot.world.width;
    const h = snapshot.world.height;
    const sx = cv.width / w;
    const sy = cv.height / h;

    const wx = (mx - camera.x) / camera.zoom;
    const wy = (my - camera.y) / camera.zoom;

    let best = null;
    let bestD2 = Infinity;
    const threshold = 18;
    const threshold2 = threshold * threshold;

    for (const a of snapshot.agents) {
      const ax = a.x * sx;
      const ay = a.y * sy;
      const dx = wx - ax;
      const dy = wy - ay;
      const d2 = dx * dx + dy * dy;
      if (d2 < bestD2) {
        bestD2 = d2;
        best = a;
      }
    }

    if (best && bestD2 <= threshold2) return best;
    return null;
  }

  function findObjectUnderCursor(snapshot, mx, my) {
    if (!snapshot || !snapshot.objects || snapshot.objects.length === 0) return null;

    const w = snapshot.world.width;
    const h = snapshot.world.height;
    const sx = cv.width / w;
    const sy = cv.height / h;

    const wx = (mx - camera.x) / camera.zoom;
    const wy = (my - camera.y) / camera.zoom;

    let best = null;
    let bestD2 = Infinity;
    const threshold = 10;
    const threshold2 = threshold * threshold;

    for (const o of snapshot.objects) {
      const ox = o.x * sx;
      const oy = o.y * sy;
      const dx = wx - ox;
      const dy = wy - oy;
      const d2 = dx * dx + dy * dy;
      if (d2 < bestD2) {
        bestD2 = d2;
        best = o;
      }
    }

    if (best && bestD2 <= threshold2) return best;
    return null;
  }

  function renderAgentTooltip(agent) {
    if (!agentTooltip) return;
    if (!agent) {
      agentTooltip.style.display = 'none';
      return;
    }

    const inv = agent.inventory || {};
    const byType = inv.by_type || {};
    const food = inv.food ?? null;

    const invParts = [];
    const keys = Object.keys(byType);
    keys.sort();
    for (const k of keys) {
      const v = byType[k];
      if (!v) continue;
      invParts.push(`${ruObj[k] || k}=${v}`);
    }
    if (food !== null) {
      invParts.push(`еда=${food}`);
    }

    const tools = agent.tools_list || [];
    const toolParts = [];
    for (const t of tools) {
      const kind = t.kind || null;
      const label = kind ? (ruToolKind[kind] || kind) : (t.tool_type || 'tool');
      const d = (t.durability_left === undefined || t.durability_left === null) ? null : t.durability_left.toFixed(0);
      toolParts.push(d ? `${label} (${d}%)` : `${label}`);
    }

    const title = escapeHtml(agent.name || agent.id);
    const invLine = invParts.length ? escapeHtml(invParts.join(', ')) : 'пусто';
    const toolLine = toolParts.length ? escapeHtml(toolParts.join(', ')) : 'нет';

    const ownerLine = agent.owner_username
      ? `<div class="muted">создатель: <span class="mono">${escapeHtml(agent.owner_username)}</span></div>`
      : '';

    const swimLine = agent.is_swimming
      ? `<div class="muted">статус: <span class="mono">плавает</span> (${escapeHtml(agent.water_ticks ?? 0)})</div>`
      : '';

    agentTooltip.innerHTML = `
      <div class="title">${title}</div>
      ${ownerLine}
      ${swimLine}
      <div class="muted">Инвентарь:</div>
      <div class="mono">${invLine}</div>
      <div style="height:6px"></div>
      <div class="muted">Инструменты:</div>
      <div class="mono">${toolLine}</div>
    `;
    agentTooltip.style.display = 'block';
  }

  function renderObjectTooltip(obj) {
    if (!agentTooltip) return;
    if (!obj) {
      agentTooltip.style.display = 'none';
      return;
    }

    const title = `${ruObj[obj.type] || obj.type}`;
    const qty = (obj.quantity === undefined || obj.quantity === null) ? 1 : obj.quantity;

    const nutrition = (obj.nutrition === undefined || obj.nutrition === null) ? null : obj.nutrition;
    const toxicity = (obj.toxicity === undefined || obj.toxicity === null) ? null : obj.toxicity;
    const hardness = (obj.hardness === undefined || obj.hardness === null) ? null : obj.hardness;
    const durability = (obj.durability === undefined || obj.durability === null) ? null : obj.durability;

    const lines = [];
    lines.push(`кол-во=${qty}`);
    if (nutrition !== null && nutrition > 0) lines.push(`питательность=${nutrition.toFixed(2)}`);
    if (toxicity !== null && toxicity > 0) lines.push(`токсичность=${toxicity.toFixed(2)}`);
    if (hardness !== null && hardness > 0) lines.push(`твёрдость=${hardness.toFixed(2)}`);
    if (durability !== null && durability > 0) lines.push(`прочность=${durability.toFixed(2)}`);

    agentTooltip.innerHTML = `
      <div class="title">${escapeHtml(title)}</div>
      <div class="mono">${escapeHtml(lines.join(', '))}</div>
    `;
    agentTooltip.style.display = 'block';
  }

  function positionAgentTooltip(mx, my) {
    if (!agentTooltip) return;
    const pad = 12;
    const wrap = document.getElementById('canvasWrap');
    if (!wrap) return;

    const rect = wrap.getBoundingClientRect();
    const maxX = rect.width - agentTooltip.offsetWidth - pad;
    const maxY = rect.height - agentTooltip.offsetHeight - pad;
    const x = Math.max(pad, Math.min(maxX, mx + pad));
    const y = Math.max(pad, Math.min(maxY, my + pad));
    agentTooltip.style.left = `${x}px`;
    agentTooltip.style.top = `${y}px`;
  }

  cv.addEventListener('mousemove', (e) => {
    if (!lastSnapshot) return;
    const rect = cv.getBoundingClientRect();
    // Mouse is in CSS pixels; convert to canvas pixels for hit-testing.
    const mxCss = e.clientX - rect.left;
    const myCss = e.clientY - rect.top;
    const scaleX = cv.width / rect.width;
    const scaleY = cv.height / rect.height;
    const mx = mxCss * scaleX;
    const my = myCss * scaleY;

    const hs = getHoverSnapshot();
    const a = findAgentUnderCursor(hs, mx, my);
    if (a) {
      renderAgentTooltip(a);
      positionAgentTooltip(mxCss, myCss);
      return;
    }

    const o = findObjectUnderCursor(hs, mx, my);
    if (o) {
      renderObjectTooltip(o);
      positionAgentTooltip(mxCss, myCss);
      return;
    }

    renderAgentTooltip(null);
  });

  cv.addEventListener('mouseleave', () => {
    renderAgentTooltip(null);
  });

  function draw(snapshot) {
    const w = snapshot.world.width;
    const h = snapshot.world.height;

    ctx.clearRect(0, 0, cv.width, cv.height);

    // Apply camera transform
    ctx.save();
    ctx.translate(camera.x, camera.y);
    ctx.scale(camera.zoom, camera.zoom);

    // Scale world to canvas
    const sx = cv.width / w;
    const sy = cv.height / h;

    // Terrain (water) from saved map (cached as 1px-per-cell offscreen)
    if (worldMapCache && worldMapCache.w === w && worldMapCache.h === h) {
      if (!worldMapCache.off) {
        worldMapCache.off = buildWaterOffscreen(w, h, worldMapCache.water);
      }
      if (worldMapCache.off) {
        ctx.globalAlpha = 1.0;
        ctx.drawImage(worldMapCache.off, 0, 0, w * sx, h * sy);
      }
    } else {
      // Map/world size changed (e.g., admin applied a new map). Reload map.
      loadWorldMap();
    }

    // Objects
    for (const o of objectsState.values()) {
      ctx.fillStyle = colorForObject(o.type);
      ctx.globalAlpha = 0.7;
      ctx.fillRect(o.x * sx, o.y * sy, Math.max(1, sx*0.7), Math.max(1, sy*0.7));
    }

    // Agents
    for (const a of snapshot.agents) {
      const prev = agentRenderState.get(a.id) || { x: a.x, y: a.y, facing: 'right' };
      const dx = a.x - prev.x;
      const facing = dx < 0 ? 'left' : dx > 0 ? 'right' : prev.facing;
      agentRenderState.set(a.id, { x: a.x, y: a.y, facing });

      const img = getSpriteSheet(a.sex);
      const ready = img.complete && img.naturalWidth > 0;
      const px = a.x * sx;
      const py = a.y * sy;

      // Draw sprite (fallback to circle if sprite not loaded yet)
      if (ready) {
        const frame = chooseFrame({ ...a, facing }, snapshot.timestep);
        const r = getFrameRect(img, frame.col, frame.row);
        const drawH = a.is_child ? 30 : 44;
        const drawW = Math.round((r.sw / r.sh) * drawH);

        ctx.save();
        ctx.translate(px, py);

        if (frame.flip) {
          ctx.scale(-1, 1);
        }

        // Anchor at feet
        const ox = frame.flip ? -drawW / 2 : -drawW / 2;
        const oy = -drawH;
        ctx.globalAlpha = 1.0;
        ctx.drawImage(img, r.sx, r.sy, r.sw, r.sh, ox, oy, drawW, drawH);
        ctx.restore();
      } else {
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = colorForAgent(a);
        const r = 4;
        ctx.beginPath();
        ctx.arc(px, py, r, 0, Math.PI * 2);
        ctx.fill();
      }

      if (a.is_swimming) {
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.strokeStyle = 'rgba(70,160,255,0.95)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(px, py - 2, 9, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      // Speech bubble (placeholder: last action)
      const who = a.name || a.id;
      let bubbleText = `${who}`;
      if (a.is_child) {
        bubbleText = `${who} (ребёнок)`;
      }
      if (a.pregnant) {
        const pr = a.pregnancy_remaining ?? 0;
        bubbleText = `${who}: беременность (${pr})`;
      }
      if (a.speech) {
        bubbleText = `${who}: ${a.speech}`;
      } else if (a.is_swimming) {
        bubbleText = `${who}: плавает`;
      } else if (a.last_action) {
        bubbleText = `${who}: ${actionToRu(a.last_action)}`;
      }
      ctx.save();
      ctx.font = '12px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial';
      const padX = 6;
      const padY = 4;
      const textW = ctx.measureText(bubbleText).width;
      const bw = textW + padX * 2;
      const bh = 18;
      const bx = px - bw / 2;
      const by = py - 58;
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = '#11162a';
      ctx.strokeStyle = 'rgba(255,255,255,0.25)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.roundRect(bx, by, bw, bh, 8);
      ctx.fill();
      ctx.stroke();
      ctx.globalAlpha = 1.0;
      ctx.fillStyle = '#e7e9ee';
      ctx.fillText(bubbleText, bx + padX, by + 13);
      ctx.restore();
    }

    // Night overlay
    if (snapshot.world && snapshot.world.is_daytime === false) {
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = '#02040d';
      ctx.fillRect(0, 0, cv.width, cv.height);
      ctx.restore();
    }
  }

  function renderEvents(snapshot) {
    const el = document.getElementById('events');
    el.innerHTML = '';
    const events = snapshot.events || [];
    const nameById = new Map((snapshot.agents || []).map(a => [a.id, a.name || a.id]));
    for (let i = events.length - 1; i >= 0; i--) {
      const e = events[i];
      const div = document.createElement('div');
      div.className = 'event';
      if (e.type === 'agent_action') {
        const who = nameById.get(e.agent_id) || e.agent_id;
        div.textContent = `[t=${e.timestamp}] ${who} -> ${actionToRu(e.action)} успех=${e.success} награда=${(e.reward ?? 0).toFixed(2)}`;
      } else if (e.type === 'communication') {
        const speaker = nameById.get(e.speaker_id) || e.speaker_id;
        const listener = nameById.get(e.listener_id) || e.listener_id;
        div.textContent = `[t=${e.timestamp}] ${speaker} сказал '${e.token}' → ${listener} (успех=${e.success})`;
      } else {
        const who = e.agent_id ? (nameById.get(e.agent_id) || e.agent_id) : '';
        div.textContent = `[t=${e.timestamp}] ${e.type} ${who}`;
      }
      el.appendChild(div);
    }
  }

  function renderStatus(snapshot) {
    const lang = snapshot.language || {};
    const pct = (x) => (x === undefined || x === null) ? '—' : `${(x * 100).toFixed(0)}%`;
    const num = (x) => (x === undefined || x === null) ? '—' : `${x}`;

    const viewers = (snapshot.online && snapshot.online.viewers !== undefined && snapshot.online.viewers !== null)
      ? snapshot.online.viewers
      : '—';

    const day = snapshot.world.day ?? 0;
    const hh = String(snapshot.world.hour ?? 0).padStart(2, '0');
    const mm = String(snapshot.world.minute ?? 0).padStart(2, '0');
    const isDay = snapshot.world.is_daytime ?? true;
    const dayNight = isDay ? 'день' : 'ночь';
    const runNo = (snapshot.run_number !== undefined && snapshot.run_number !== null)
      ? snapshot.run_number
      : ((snapshot.run_info && snapshot.run_info.number !== undefined && snapshot.run_info.number !== null)
        ? snapshot.run_info.number
        : 1);

    const prog = snapshot.progress || {};
    const needsLoad = (prog.needs_load_avg === undefined || prog.needs_load_avg === null) ? '—' : prog.needs_load_avg.toFixed(2);
    const critical = (prog.critical_share === undefined || prog.critical_share === null) ? '—' : `${(prog.critical_share * 100).toFixed(0)}%`;
    const avgAge = (prog.avg_age_alive === undefined || prog.avg_age_alive === null) ? '—' : prog.avg_age_alive.toFixed(0);
    const maxAge = (prog.max_age_alive === undefined || prog.max_age_alive === null) ? '—' : `${prog.max_age_alive}`;
    const combOk = (prog.combine_success_recent === undefined || prog.combine_success_recent === null) ? '—' : `${prog.combine_success_recent}`;
    const totalTools = (prog.total_tools === undefined || prog.total_tools === null) ? '—' : `${prog.total_tools}`;

    const deaths = prog.death_causes_recent || {};
    const deathParts = [];
    const deathKeys = Object.keys(deaths);
    deathKeys.sort();
    for (const k of deathKeys) {
      deathParts.push(`${k}=${deaths[k]}`);
    }
    const deathLine = deathParts.length ? deathParts.join(', ') : '—';

    const kinds = prog.tool_kinds || {};
    const kindParts = [];
    const kindKeys = Object.keys(kinds);
    kindKeys.sort();
    for (const k of kindKeys) {
      const label = ruToolKind[k] || k;
      kindParts.push(`${label}=${kinds[k]}`);
    }
    const kindLine = kindParts.length ? kindParts.join(', ') : '—';

    status.innerHTML = `
      <span title="Сколько людей сейчас открыли страницу и подключены по WebSocket"><b>онлайн</b>: ${viewers}</span>
      <span title="Номер текущего прогона симуляции (auto-restart при вымирании)"><b>симуляция</b>: №${runNo}</span>
      <span title="Текущий шаг симуляции (timestep)"><b>t</b>: ${snapshot.timestep}</span>
      <span title="Номер дня в симуляции (счётчик суток)"><b>день</b>: ${day}</span>
      <span title="Внутрисуточное время + день/ночь (влияет на сонливость и поведение)"><b>время</b>: ${hh}:${mm} (${dayNight})</span>
      <span title="Количество живых агентов сейчас"><b>agents</b>: ${snapshot.agents.length}</span>
      <span title="Сезон (0-3: весна/лето/осень/зима)"><b>season</b>: ${snapshot.world.season}</span>
      <span title="Температура среды (°C)"><b>T</b>: ${snapshot.world.temperature.toFixed(1)}</span>
      <span title="Средняя нагрузка нужд по живым: (голод+жажда+сонливость)/3, диапазон 0..1"><b>нужды</b>: ${needsLoad}</span>
      <span title="Доля живых агентов в критическом состоянии: max(голод,жажда,сонливость) ≥ 0.85"><b>критич</b>: ${critical}</span>
      <span title="Возраст живых агентов: средний/максимальный (в шагах симуляции)"><b>возраст</b>: ${avgAge}/${maxAge}</span>
      <span title="Успешные крафты (combine, success=true) за последние 200 событий"><b>крафт(ok/200)</b>: ${combOk}</span>
      <span title="Сколько инструментов существует в мире сейчас (в Environment.tools)"><b>инструм</b>: ${totalTools}</span>
      <span title="Распределение инструментов по 'kind' (именованные рецепты и unknown)"><b>типы</b>: ${kindLine}</span>
      <span title="Смерти по причинам за последние 200 событий"><b>смерти(200)</b>: ${deathLine}</span>
      <span title="Размер словаря: количество устойчивых токенов (по весу в лексиконе)"><b>язык: словарь</b>: ${num(lang.lexicon_size)}</span>
      <span title="Стабильность: насколько доминирует лучший токен для каждого смысла (0..100%)"><b>стабильность</b>: ${pct(lang.stability)}</span>
      <span title="Сходимость: насколько агенты используют похожие соответствия смысл→токен (0..100%)"><b>сходимость</b>: ${pct(lang.convergence)}</span>
      <span title="Успешность коммуникации за последние 200 событий: доля успехов и количество попыток"><b>успех (200)</b>: ${pct(lang.comm_success_rate_recent)} (${num(lang.comm_count_recent)})</span>
    `;
  }

  let lastSnapshot = null;
  let lastAgents = [];
  let lastPaintMs = 0;
  const targetFrameMs = 1000 / 30;

  let renderLoopStarted = false;
  function renderLoop(now) {
    try {
      if (lastSnapshot) {
        if (now - lastPaintMs >= targetFrameMs) {
          draw(lastSnapshot);
          lastPaintMs = now;
        }
      }
    } catch (e) {}
    requestAnimationFrame(renderLoop);
  }

  // RTS-style object state (applied from deltas)
  const objectsState = new Map();
  let lastRunNumber = null;

  const ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws');

  function ping() {
    try { ws.send('ping'); } catch (e) {}
  }

  ws.onopen = () => {
    // Keep connection alive; server pushes updates.
    setInterval(() => ping(), 1000);
  };

  ws.onmessage = (ev) => {
    let snapshot;
    try {
      snapshot = JSON.parse(ev.data);
    } catch {
      return;
    }

    // Agents may be omitted in delta snapshots; keep the last known list for hover.
    try {
      if (snapshot && Object.prototype.hasOwnProperty.call(snapshot, 'agents') && Array.isArray(snapshot.agents)) {
        lastAgents = snapshot.agents;
      }
    } catch (e) {}

    // Apply object sync/deltas
    try {
      const runNo = snapshot.run_number ?? (snapshot.run_info ? snapshot.run_info.number : null);
      const isNewRun = (runNo !== null && runNo !== undefined && lastRunNumber !== runNo);
      const full = Boolean(snapshot.full_sync) || Boolean(snapshot.objects_full) || isNewRun;

      if (full) {
        objectsState.clear();
        const fullList = snapshot.objects_full || snapshot.objects || [];
        for (const o of fullList) {
          if (!o || !o.id) continue;
          objectsState.set(o.id, o);
        }
        lastRunNumber = runNo;
      } else {
        for (const o of (snapshot.objects_add || [])) {
          if (!o || !o.id) continue;
          objectsState.set(o.id, o);
        }
        for (const o of (snapshot.objects_update || [])) {
          if (!o || !o.id) continue;
          objectsState.set(o.id, o);
        }
        for (const oid of (snapshot.objects_remove || [])) {
          if (!oid) continue;
          objectsState.delete(oid);
        }
      }
    } catch (e) {}

    lastSnapshot = snapshot;
    renderStatus(snapshot);
    renderHistory(snapshot);
    renderEvents(snapshot);
    renderMyAgent(snapshot);

    if (!renderLoopStarted) {
      renderLoopStarted = true;
      lastPaintMs = performance.now();
      requestAnimationFrame(renderLoop);
    }
  };

  ws.onclose = () => {
    status.innerHTML = '<b>WS disconnected</b>';
  };

  const authUser = document.getElementById('authUser');
  const authPass = document.getElementById('authPass');
  const btnLogin = document.getElementById('btnLogin');
  const btnRegister = document.getElementById('btnRegister');
  const btnLogout = document.getElementById('btnLogout');
  const authState = document.getElementById('authState');
  const chatAuth = document.getElementById('chatAuth');
  const chatBox = document.getElementById('chatBox');
  const chatMessages = document.getElementById('chatMessages');
  const chatInput = document.getElementById('chatInput');
  const btnSend = document.getElementById('btnSend');
  const chatAnnounce = document.getElementById('chatAnnounce');
  const chatAnnounceText = document.getElementById('chatAnnounceText');

  const worldControls = document.getElementById('worldControls');
  const btnCreateAgent = document.getElementById('btnCreateAgent');
  const createAgentState = document.getElementById('createAgentState');

  const agentModal = document.getElementById('agentModal');
  const btnCloseAgentModal = document.getElementById('btnCloseAgentModal');
  const agentName = document.getElementById('agentName');
  const agentStatsStrength = document.getElementById('agentStatsStrength');
  const agentStatsIntelligence = document.getElementById('agentStatsIntelligence');
  const agentStatsSocial = document.getElementById('agentStatsSocial');
  const agentStatsEndurance = document.getElementById('agentStatsEndurance');
  const agentStatsLeft = document.getElementById('agentStatsLeft');
  const btnPresetInventor = document.getElementById('btnPresetInventor');
  const btnPresetSurvivor = document.getElementById('btnPresetSurvivor');
  const btnPresetLeader = document.getElementById('btnPresetLeader');
  const btnSubmitAgent = document.getElementById('btnSubmitAgent');
  const agentModalState = document.getElementById('agentModalState');

  const accountBar = document.getElementById('accountBar');
  const accountText = document.getElementById('accountText');
  const adminLink = document.getElementById('adminLink');
  const btnLogout2 = document.getElementById('btnLogout2');

  const newsList = document.getElementById('newsList');
  const newsAdmin = document.getElementById('newsAdmin');
  const newsTitle = document.getElementById('newsTitle');
  const newsText = document.getElementById('newsText');
  const btnPostNews = document.getElementById('btnPostNews');
  const newsAdminState = document.getElementById('newsAdminState');

  let chatWs = null;

  function setAuthState(stateText) {
    authState.textContent = stateText || '';
  }

  function localizeDetail(detail) {
    const d = (detail || '').toString();
    if (!d) return '';
    const map = {
      invalid_username_or_password: 'Неверный логин или пароль',
      invalid_credentials: 'Неверный логин или пароль',
      invalid_token: 'Сессия недействительна. Войдите заново.',
      not_authenticated: 'Нужно войти в аккаунт',
      not_admin: 'Недостаточно прав (нужен администратор)',
      registration_closed: 'Регистрация закрыта. Обратитесь к администратору.',
      admin_already_exists: 'Администратор уже создан',
      username_taken: 'Этот логин уже занят',
      username_too_short: 'Логин слишком короткий',
      password_too_short: 'Пароль слишком короткий',
      invalid_agent_name: 'Некорректное имя агента',
      invalid_agent_sex: 'Некорректный пол агента',
      invalid_agent_stats: 'Некорректные характеристики агента',
      simulation_not_ready: 'Симуляция ещё не готова. Попробуйте чуть позже.',
      agent_already_created: 'У вас уже есть агент. Можно только наблюдать за ним.',
    };
    return map[d] || d;
  }

  function setHasAgentFlag(hasAgent) {
    localStorage.setItem('evosim_has_agent', hasAgent ? '1' : '0');
  }

  function findMyAgent(snapshot) {
    const u = localStorage.getItem('evosim_username') || '';
    if (!u || !snapshot || !snapshot.agents) return null;
    return snapshot.agents.find(a => a.owner_username === u) || null;
  }

  function fmtPct01(x) {
    if (x === undefined || x === null) return '—';
    return `${Math.round(x * 100)}%`;
  }

  function renderMyAgent(snapshot) {
    if (!myAgentState || !myAgentBody) return;
    const agent = findMyAgent(snapshot);
    if (!agent) {
      myAgentBody.style.display = 'none';
      myAgentState.style.display = '';
      myAgentState.textContent = localStorage.getItem('evosim_has_agent') === '1'
        ? 'Ваш агент сейчас не найден в мире (возможно, ещё не заспавнился или погиб).'
        : 'Войдите и создайте своего агента, чтобы следить за ним.';
      return;
    }

    myAgentBody.style.display = '';
    myAgentState.style.display = 'none';

    myAgentName.textContent = agent.name || agent.id;
    myAgentOwner.textContent = `user: ${agent.owner_username || '—'}`;

    const swim = agent.is_swimming ? ' · плавает' : '';
    const lastAct = agent.last_action ? ` · ${actionToRu(agent.last_action)}` : '';
    myAgentStatus.textContent = `t=${snapshot.timestep} · (${agent.x},${agent.y})${swim}${lastAct}`;

    const needs = `голод ${fmtPct01(agent.hunger)} · жажда ${fmtPct01(agent.thirst)} · сонливость ${fmtPct01(agent.sleepiness)}`;
    myAgentNeeds.textContent = needs;

    const vitals = `здоровье ${fmtPct01(agent.health)} · энергия ${fmtPct01(agent.energy)} · возраст ${agent.age}/${agent.max_age}`;
    myAgentVitals.textContent = vitals;
  }

  function hasAgent() {
    return localStorage.getItem('evosim_has_agent') === '1';
  }

  function getToken() {
    return localStorage.getItem('evosim_token');
  }

  function setToken(token, username) {
    localStorage.setItem('evosim_token', token);
    if (username) localStorage.setItem('evosim_username', username);
  }

  function setAdminFlag(isAdmin) {
    localStorage.setItem('evosim_is_admin', isAdmin ? '1' : '0');
  }

  function isAdmin() {
    return localStorage.getItem('evosim_is_admin') === '1';
  }

  function clearToken() {
    localStorage.removeItem('evosim_token');
    localStorage.removeItem('evosim_username');
    localStorage.removeItem('evosim_is_admin');
  }

  function setChatAnnouncement(text) {
    const t = String(text || '').trim();
    if (!chatAnnounce || !chatAnnounceText) return;
    if (!t) {
      chatAnnounce.style.display = 'none';
      chatAnnounceText.textContent = '';
      return;
    }
    chatAnnounce.style.display = '';
    chatAnnounceText.textContent = t;
  }

  function appendChatLine(item) {
    const div = document.createElement('div');
    div.dataset.msgId = String(item.id ?? '');
    div.style.padding = '6px 6px';
    div.style.borderBottom = '1px solid rgba(255,255,255,0.06)';
    const ts = (item.created_at || '').replace('T', ' ').slice(0, 19);
    const adminTag = item.is_admin ? ' > Администратор' : '';
    div.textContent = `${ts} ${item.username}${adminTag}: ${item.text}`;
    chatMessages.appendChild(div);
    chatMessages.scrollTop = chatMessages.scrollHeight;
  }

  function deleteChatLineById(id) {
    if (!chatMessages) return;
    const q = `[data-msg-id="${CSS.escape(String(id))}"]`;
    const el = chatMessages.querySelector(q);
    if (el) el.remove();
  }

  function setLoggedInUI(username) {
    // Hide login form and show account bar
    authUser.value = '';
    authPass.value = '';
    authUser.disabled = true;
    authPass.disabled = true;
    btnLogin.style.display = 'none';
    btnRegister.style.display = 'none';
    btnLogout.style.display = 'none';
    if (chatAuth) chatAuth.style.display = 'none';
    accountBar.style.display = '';
    chatBox.style.display = '';
    btnSend.disabled = false;
    const tag = isAdmin() ? ' > Администратор' : '';
    accountText.textContent = username ? `вы вошли как ${username}${tag}` : `вы вошли${tag}`;
    adminLink.style.display = isAdmin() ? '' : 'none';
    setAuthState('');
    newsAdmin.style.display = isAdmin() ? '' : 'none';
    if (worldControls) worldControls.style.display = '';

    if (btnCreateAgent) {
      const locked = hasAgent();
      btnCreateAgent.disabled = locked;
      setCreateAgentState(locked ? 'агент уже создан' : '');
    }
  }

  function setLoggedOutUI() {
    accountBar.style.display = 'none';
    adminLink.style.display = 'none';
    btnLogout.style.display = 'none';
    btnLogin.style.display = '';
    btnRegister.style.display = '';
    if (chatAuth) chatAuth.style.display = '';
    authUser.disabled = false;
    authPass.disabled = false;
    chatBox.style.display = 'none';
    btnSend.disabled = true;
    setAuthState('');
    newsAdmin.style.display = 'none';
    if (worldControls) worldControls.style.display = 'none';
    if (btnCreateAgent) btnCreateAgent.disabled = true;
    setCreateAgentState('');
  }

  function setCreateAgentState(t) {
    if (createAgentState) createAgentState.textContent = t || '';
  }

  function setAgentModalState(t) {
    if (agentModalState) agentModalState.textContent = t || '';
  }

  function readStat(el) {
    try {
      const v = parseInt(el.value || '0', 10);
      if (Number.isNaN(v)) return 0;
      return Math.max(0, Math.min(3, v));
    } catch (e) {
      return 0;
    }
  }

  function writeStat(el, v) {
    try {
      el.value = String(Math.max(0, Math.min(3, parseInt(v || 0, 10) || 0)));
    } catch (e) {}
  }

  function getStatsPoints() {
    return {
      strength: readStat(agentStatsStrength),
      intelligence: readStat(agentStatsIntelligence),
      social: readStat(agentStatsSocial),
      endurance: readStat(agentStatsEndurance),
    };
  }

  function sumStats(s) {
    return (s.strength || 0) + (s.intelligence || 0) + (s.social || 0) + (s.endurance || 0);
  }

  function updateStatsLeft() {
    const s = getStatsPoints();
    const left = 5 - sumStats(s);
    if (agentStatsLeft) {
      agentStatsLeft.textContent = left >= 0 ? `осталось очков: ${left}` : `лишние очки: ${-left}`;
      agentStatsLeft.style.color = left === 0 ? '#41d67e' : (left > 0 ? '#aab0c0' : '#ff4d6d');
    }
    if (btnSubmitAgent) btnSubmitAgent.disabled = (left !== 0);
  }

  function applyPreset(name) {
    if (name === 'inventor') {
      writeStat(agentStatsStrength, 1);
      writeStat(agentStatsIntelligence, 3);
      writeStat(agentStatsSocial, 0);
      writeStat(agentStatsEndurance, 1);
    } else if (name === 'survivor') {
      writeStat(agentStatsStrength, 3);
      writeStat(agentStatsIntelligence, 0);
      writeStat(agentStatsSocial, 0);
      writeStat(agentStatsEndurance, 2);
    } else if (name === 'leader') {
      writeStat(agentStatsStrength, 1);
      writeStat(agentStatsIntelligence, 1);
      writeStat(agentStatsSocial, 3);
      writeStat(agentStatsEndurance, 0);
    }
    updateStatsLeft();
  }

  function openAgentModal() {
    if (!agentModal) return;
    setAgentModalState('');
    if (agentName) agentName.value = '';
    writeStat(agentStatsStrength, 0);
    writeStat(agentStatsIntelligence, 0);
    writeStat(agentStatsSocial, 0);
    writeStat(agentStatsEndurance, 0);
    updateStatsLeft();
    agentModal.style.display = 'flex';
    try { agentName && agentName.focus(); } catch (e) {}
  }

  function closeAgentModal() {
    if (!agentModal) return;
    agentModal.style.display = 'none';
    setAgentModalState('');
  }

  function getAgentSex() {
    const el = document.querySelector('input[name="agentSex"]:checked');
    return el ? el.value : 'male';
  }

  async function submitAgent() {
    const token = getToken();
    if (!token) {
      setCreateAgentState('нужно войти');
      return;
    }
    const name = (agentName && agentName.value ? agentName.value : '').trim();
    const sex = getAgentSex();
    const stats = getStatsPoints();
    if (sumStats(stats) !== 5) {
      setAgentModalState('нужно распределить ровно 5 очков');
      return;
    }
    setAgentModalState('...');
    try {
      const res = await fetch('/api/agents/create?token=' + encodeURIComponent(token), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ display_name: name, sex, stats })
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        setAgentModalState(localizeDetail(data.detail) || `Ошибка ${res.status}`);
        return;
      }
      const a = data.agent || {};
      setCreateAgentState(`создан: ${a.name || a.id}`);
      setHasAgentFlag(true);
      if (btnCreateAgent) btnCreateAgent.disabled = true;
      closeAgentModal();
    } catch (e) {
      setAgentModalState('ошибка сети');
    }
  }

  async function validateTokenAndSyncUI() {
    const token = getToken();
    if (!token) {
      setLoggedOutUI();
      return;
    }
    try {
      const res = await fetch('/api/auth/me?token=' + encodeURIComponent(token), { cache: 'no-store' });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        clearToken();
        setLoggedOutUI();
        return;
      }
      localStorage.setItem('evosim_username', data.username);
      setAdminFlag(!!data.is_admin);
      setHasAgentFlag(!!data.has_agent);
      setLoggedInUI(data.username);
    } catch (e) {
      // If network fails, fall back to stored info
      const username = localStorage.getItem('evosim_username') || '';
      setLoggedInUI(username);
    }
  }

  function connectChat() {
    const token = getToken();
    if (!token) {
      setLoggedOutUI();
      return;
    }

    const username = localStorage.getItem('evosim_username') || '';
    setLoggedInUI(username);
    chatMessages.innerHTML = '';

    if (chatWs) {
      try { chatWs.close(); } catch (e) {}
      chatWs = null;
    }

    const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/chat/ws?token=' + encodeURIComponent(token);
    chatWs = new WebSocket(wsUrl);

    chatWs.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); } catch { return; }
      if (msg.type === 'history') {
        const items = msg.items || [];
        chatMessages.innerHTML = '';
        for (const it of items) appendChatLine(it);
        setChatAnnouncement(msg.announcement || '');
        return;
      }
      if (msg.type === 'message' && msg.item) {
        appendChatLine(msg.item);
        return;
      }
      if (msg.type === 'announcement') {
        setChatAnnouncement(msg.text || '');
        return;
      }
      if (msg.type === 'moderation' && msg.event === 'delete') {
        deleteChatLineById(msg.id);
        return;
      }
      if (msg.type === 'banned') {
        setAuthState('вы заблокированы в чате');
        try { if (chatBox) chatBox.style.display = 'none'; } catch (e) {}
        return;
      }
      if (msg.type === 'error' && msg.detail === 'chat_banned') {
        setAuthState('вы заблокированы в чате');
        return;
      }
    };

    chatWs.onclose = () => {
      setAuthState('чат отключен');
    };
  }

  async function authCall(path) {
    const username = (authUser.value || '').trim();
    const password = authPass.value || '';
    setAuthState('...');
    const res = await fetch(path, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password }),
    });
    const data = await res.json().catch(() => ({}));
    if (!res.ok) {
      setAuthState(localizeDetail(data.detail) || `Ошибка ${res.status}`);
      return;
    }
    setToken(data.token, data.username);
    setAdminFlag(!!data.is_admin);
    connectChat();
    await loadNews();
  }

  btnLogin.addEventListener('click', async () => {
    try { await authCall('/api/auth/login'); } catch (e) { setAuthState('ошибка сети'); }
  });
  btnRegister.addEventListener('click', async () => {
    try { await authCall('/api/auth/register'); } catch (e) { setAuthState('ошибка сети'); }
  });
  btnLogout.addEventListener('click', () => {
    clearToken();
    if (chatWs) {
      try { chatWs.close(); } catch (e) {}
      chatWs = null;
    }
    setLoggedOutUI();
    loadNews();
  });

  if (btnCreateAgent) btnCreateAgent.addEventListener('click', () => openAgentModal());
  if (btnCloseAgentModal) btnCloseAgentModal.addEventListener('click', () => closeAgentModal());
  if (agentModal) {
    agentModal.addEventListener('click', (e) => {
      if (e.target === agentModal) closeAgentModal();
    });
  }
  if (btnSubmitAgent) btnSubmitAgent.addEventListener('click', () => submitAgent());

  if (agentStatsStrength) agentStatsStrength.addEventListener('input', () => updateStatsLeft());
  if (agentStatsIntelligence) agentStatsIntelligence.addEventListener('input', () => updateStatsLeft());
  if (agentStatsSocial) agentStatsSocial.addEventListener('input', () => updateStatsLeft());
  if (agentStatsEndurance) agentStatsEndurance.addEventListener('input', () => updateStatsLeft());
  if (btnPresetInventor) btnPresetInventor.addEventListener('click', () => applyPreset('inventor'));
  if (btnPresetSurvivor) btnPresetSurvivor.addEventListener('click', () => applyPreset('survivor'));
  if (btnPresetLeader) btnPresetLeader.addEventListener('click', () => applyPreset('leader'));

  updateStatsLeft();

  btnLogout2.addEventListener('click', () => {
    clearToken();
    if (chatWs) {
      try { chatWs.close(); } catch (e) {}
      chatWs = null;
    }
    setLoggedOutUI();
    loadNews();
  });

  function setNewsAdminState(t) {
    newsAdminState.textContent = t || '';
  }

  function renderNews(items) {
    newsList.innerHTML = '';
    const arr = items || [];
    for (let i = arr.length - 1; i >= 0; i--) {
      const n = arr[i];
      const wrap = document.createElement('div');
      wrap.style.padding = '8px 10px';
      wrap.style.border = '1px solid rgba(255,255,255,0.08)';
      wrap.style.borderRadius = '10px';
      wrap.style.marginBottom = '8px';
      wrap.style.background = 'rgba(255,255,255,0.03)';

      const t = (n.created_at || '').replace('T', ' ').slice(0, 19);
      const title = document.createElement('div');
      title.style.fontWeight = '700';
      title.style.marginBottom = '4px';
      title.textContent = n.title;
      const meta = document.createElement('div');
      meta.style.fontSize = '12px';
      meta.style.color = '#aab0c0';
      meta.style.marginBottom = '6px';
      meta.textContent = `${t} — ${n.author_username}`;
      const body = document.createElement('div');
      body.style.whiteSpace = 'pre-wrap';
      body.textContent = n.text;

      wrap.appendChild(title);
      wrap.appendChild(meta);
      wrap.appendChild(body);

      if (isAdmin() && getToken()) {
        const row = document.createElement('div');
        row.className = 'row';
        row.style.marginTop = '8px';
        const btnDel = document.createElement('button');
        btnDel.className = 'secondary';
        btnDel.textContent = 'Удалить';
        btnDel.addEventListener('click', async () => {
          try {
            const res = await fetch('/api/admin/news/' + n.id + '?token=' + encodeURIComponent(getToken()), { method: 'DELETE' });
            if (!res.ok) return;
            await loadNews();
          } catch (e) {}
        });
        row.appendChild(btnDel);
        wrap.appendChild(row);
      }

      newsList.appendChild(wrap);
    }
  }

  async function loadNews() {
    try {
      const res = await fetch('/api/news?limit=20', { cache: 'no-store' });
      const data = await res.json().catch(() => ({}));
      renderNews(data.items || []);
    } catch (e) {
      // ignore
    }
  }

  btnPostNews.addEventListener('click', async () => {
    if (!getToken()) return;
    setNewsAdminState('...');
    try {
      const title = (newsTitle.value || '').trim();
      const text = (newsText.value || '').trim();
      const res = await fetch('/api/admin/news?token=' + encodeURIComponent(getToken()), {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, text }),
      });
      const data = await res.json().catch(() => ({}));
      if (!res.ok) {
        setNewsAdminState(localizeDetail(data.detail) || `Ошибка ${res.status}`);
        return;
      }
      newsTitle.value = '';
      newsText.value = '';
      setNewsAdminState('опубликовано');
      await loadNews();
    } catch (e) {
      setNewsAdminState('ошибка сети');
    }
  });

  function sendChat() {
    const text = (chatInput.value || '').trim();
    if (!text) return;
    if (!chatWs || chatWs.readyState !== WebSocket.OPEN) {
      setAuthState('чат не подключен');
      return;
    }
    chatWs.send(JSON.stringify({ text }));
    chatInput.value = '';
  }

  btnSend.addEventListener('click', sendChat);
  chatInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') sendChat();
  });

  validateTokenAndSyncUI();
  connectChat();
  loadNews();
  loadWorldMap();
</script>
</body>
</html>
